import type { RspressPlugin } from '@rspress/core';
import path from 'node:path';
import { existsSync, readdirSync, readFileSync } from 'node:fs';

interface BlogPost {
  slug: string;
  date: Date;
  title: string;
  dateString: string;
  authors: string[];
  excerpt: string;
  frontmatter: Record<string, string>;
}

/**
 * Parse frontmatter and content from MDX file
 */
function parseMDXFile(filePath: string): Omit<BlogPost, 'slug' | 'date'> {
  const content = readFileSync(filePath, 'utf8');
  
  // Extract frontmatter
  const frontmatterMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  const frontmatter: Record<string, string> = {};
  
  if (frontmatterMatch) {
    const frontmatterText = frontmatterMatch[1];
    frontmatterText.split('\n').forEach(line => {
      const match = line.match(/^([a-zA-Z0-9_-]+):\s*(.*)$/);
      if (match) {
        frontmatter[match[1]] = match[2];
      }
    });
  }
  
  // Extract title (first H1)
  const titleMatch = content.match(/^#\s+(.+)$/m);
  const title = titleMatch ? titleMatch[1] : '';
  
  // Extract date string (formatted like "_September 3rd, 2025_")
  const dateStringMatch = content.match(/^_(.+)_$/m);
  const dateString = dateStringMatch ? dateStringMatch[1] : '';
  
  // Extract authors from BlogAvatar component
  // Use a more lenient pattern that captures content until the closing }
  const avatarMatch = content.match(/<BlogAvatar\s+list=\{(\[[\s\S]*?\])\}\s*\/>/);
  let authors: string[] = [];
  if (avatarMatch) {
    try {
      const listStr = avatarMatch[1].replace(/'/g, '"');
      authors = JSON.parse(listStr);
    } catch (e) {
      console.warn(`Failed to parse authors from ${filePath}:`, e);
    }
  }
  
  // Extract excerpt (first paragraph after title and avatar)
  const afterAvatar = content.split(/<BlogAvatar[^>]+\/>/)[1] || '';
  const lines = afterAvatar.split('\n');
  let excerpt = '';
  let collecting = false;
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // Skip empty lines, images, and headings
    if (!trimmed || trimmed.startsWith('!') || trimmed.startsWith('#') || trimmed.startsWith('<')) {
      if (collecting && excerpt) {
        break;
      }
      continue;
    }
    
    collecting = true;
    excerpt += (excerpt ? ' ' : '') + trimmed;
    
    if (excerpt.length > 200) {
      break;
    }
  }
  
  // Clean up excerpt
  excerpt = excerpt.replace(/!\[.*?\]\(.*?\)/g, ''); // Remove markdown images
  
  // Remove HTML/JSX tags iteratively to handle nested/incomplete tags
  // This prevents incomplete multi-character sanitization vulnerabilities
  let prevExcerpt;
  let iterations = 0;
  const maxIterations = 10; // Safety limit to prevent infinite loops
  do {
    prevExcerpt = excerpt;
    excerpt = excerpt.replace(/<[^>]*>/g, '');
    iterations++;
  } while (prevExcerpt !== excerpt && iterations < maxIterations);
  
  excerpt = excerpt.replace(/\s+/g, ' ').trim(); // Normalize whitespace
  
  // Truncate if too long
  if (excerpt.length > 300) {
    excerpt = excerpt.substring(0, 297) + '...';
  }
  
  return {
    frontmatter,
    title,
    dateString,
    authors,
    excerpt,
  };
}

/**
 * Get all blog posts from a directory
 */
function getBlogPosts(blogDir: string): BlogPost[] {
  if (!existsSync(blogDir)) {
    return [];
  }

  const files = readdirSync(blogDir);
  const posts: BlogPost[] = [];
  
  files.forEach(file => {
    if (file === 'index.mdx' || file === '_meta.json' || !file.endsWith('.mdx')) {
      return;
    }
    
    const filePath = path.join(blogDir, file);
    const slug = file.replace('.mdx', '');
    
    try {
      const data = parseMDXFile(filePath);
      
      // Parse date for sorting - use frontmatter date (ISO format) for accurate sorting
      // Skip posts without a valid date
      if (!data.frontmatter.date) {
        console.warn(`Skipping ${filePath}: missing date in frontmatter`);
        return;
      }
      
      const date = new Date(data.frontmatter.date);
      if (isNaN(date.getTime())) {
        console.warn(`Skipping ${filePath}: invalid date format "${data.frontmatter.date}"`);
        return;
      }
      
      posts.push({
        slug,
        date,
        ...data,
      });
    } catch (e) {
      console.warn(`Failed to parse ${filePath}:`, e);
    }
  });
  
  // Sort by date, newest first
  posts.sort((a, b) => b.date.getTime() - a.date.getTime());
  
  return posts;
}

/**
 * Generate blog index MDX content
 */
function generateBlogIndexContent(posts: BlogPost[], lang: string): string {
  const isZh = lang === 'zh';
  
  const title = isZh ? 'Lynx 博客' : 'Lynx Blog';
  const description = isZh 
    ? '在此查看有关 Lynx 的最新文章和发布公告。'
    : 'Check here for the latest articles and release announcements about Lynx.';
  
  let content = `---
title: ${title}
sidebar: false
---

{/* This file is auto-generated by the blog-index plugin. Do not edit manually! */}

import { BlogAvatar } from '@lynx';

# ${title}

${description}

`;
  
  posts.forEach(post => {
    content += `## [${post.title}](/blog/${post.slug})

`;
    
    // Add date and authors
    if (post.dateString) {
      content += `_${post.dateString}_\n\n`;
      
      if (post.authors && post.authors.length > 0) {
        content += `<BlogAvatar list={${JSON.stringify(post.authors)}} />\n\n`;
      }
    }
    
    // Add excerpt if available
    if (post.excerpt) {
      content += `${post.excerpt}\n\n`;
    }
  });
  
  content += `---\n`;
  
  return content;
}

/**
 * Rspress plugin for auto-generating blog index pages
 */
export function pluginBlogIndex(): RspressPlugin {
  return {
    name: 'rspress-plugin-blog-index',
    addPages(config, isProd) {
      const docsDir = path.join(process.cwd(), 'docs');
      const languages = ['en', 'zh'];
      const pages: Array<{ routePath: string; content: string }> = [];
      
      languages.forEach(lang => {
        const blogDir = path.join(docsDir, lang, 'blog');
        
        if (!existsSync(blogDir)) {
          console.warn(`Blog directory not found: ${blogDir}`);
          return;
        }
        
        console.log(`Generating blog index for ${lang}...`);
        
        const posts = getBlogPosts(blogDir);
        const content = generateBlogIndexContent(posts, lang);
        
        // For 'en' (default locale), use /blog/index, for others use /lang/blog/index
        const routePath = lang === 'en' ? '/blog/index' : `/${lang}/blog/index`;
        
        pages.push({
          routePath,
          content,
        });
        
        console.log(`✓ Generated blog index for ${lang} with ${posts.length} posts at ${routePath}`);
      });
      
      return pages;
    },
  };
}
