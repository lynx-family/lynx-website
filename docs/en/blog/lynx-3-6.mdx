---
date: 2026-01-30
sidebar: false
authors: ['liujilong', 'Dugyu', 'lynx']
badge_text: 'Lynx 3.6 is released!'
description: 'Lynx 3.6 is now officially released! This release introduces reactlynx-use for improved developer experience, launch an LLM toolset to enhance AI-native development capabilities, and enhances CSS capabilities for design expressiveness. On the native side, Lynx 3.6 improves platform integration with Standalone BackgroundRuntime and asynchronous TemplateBundle creation on HarmonyOS, along with Auto Layout support for LynxView on iOS.'
---

import { BlogAvatar, CodeFold } from '@lynx';
import { PackageManagerTabs } from '@theme';
import { Go, Badge, Experimental, YouTubeIframe } from '@lynx';
import { Tab, Tabs } from '@rspress/core/theme';

_January 30th, 2026_

# Lynx 3.6: reactlynx-use, Lynx for AI, CSS for Design

<BlogAvatar list={['liujilong', 'Dugyu', 'lynx']} />

Lynx 3.6 is now officially released!

This release introduces `reactlynx-use` for improved developer experience, launch an LLM toolset to enhance AI-native development capabilities, and enhances CSS capabilities for design expressiveness.

On the native side, Lynx 3.6 improves platform integration with Standalone BackgroundRuntime and asynchronous TemplateBundle creation on HarmonyOS, along with Auto Layout support for LynxView on iOS.

Let's take a closer look at what's new in Lynx 3.6.

## `reactlynx-use`

[`reactlynx-use`](https://github.com/lynx-community/reactlynx-use) is a React-style hooks library built specifically for the ReactLynx ecosystem.

`reactlynx-use` offers a familiar interface consistent with React Hooks, deeply integrates with ReactLynx project, and is designed for Lynx’s unique cross‑platform capabilities.

It includes nearly 30 community‑proven utility hooks (such as `useEffectOnce`, `useDebounce`, etc.) and provides a set of hooks tailored for Lynx’s dual-thread architecture.

Notable additions include:

- **useVelocity**: Track the velocity and direction of tap events on the main thread.
- **useTapLock**: Constrain main-thread tap interactions to a specific direction or range.
- **useMainThreadImperativeHandle**: A main-thread counterpart of `useImperativeHandle`.
- **useEventListener**: A flexible event subscription hook supporting `exposure`, `disexposure`, and more.

These hooks make it easier to write expressive, idiomatic React code while working directly with Lynx's underlying runtime model.

![reactlynx-use](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/blog/reactlynx-use.jpeg)

## Lynx for AI

Large language models are trained on public web data and typically lack awareness of the latest Lynx features and best practices. To bridge this gap, the Lynx team and community are building a set of tools that help AI systems better understand Lynx and assist developers more effectively.

This work lays the groundwork for AI-assisted Lynx development, enabling models to reason and generate more accurately within the Lynx context.

### Lynx Docs MCP

[llms.txt](https://llmstxt.org/) is a standard that helps large language models treat website content as a searchable knowledge base.

The Lynx site fully supports this standard. For any page, simply replace the `.html` extension with `.md` to obtain the raw Markdown. For example:

- [https://lynxjs.org/llms.txt](https://lynxjs.org/llms.txt)
- [https://lynxjs.org/react/introduction.md](https://lynxjs.org/react/introduction.md)

In addition, [Lynx Docs MCP](/ai/lynx-docs-mcp) provides `llms.txt` along with carefully crafted prompts, enabling your coding agents (e.g., Gemini, Claude, Cursor, or Copilot) to efficiently access Lynx documentation and better support development tasks.

### Lynx DevTool MCP

[Lynx DevTool MCP](/ai/lynx-devtool-mcp) is an MCP server that helps coding agents connect to devices and inspect/control Lynx pages much like DevTools: read elements/console/source code, perform interactions such as clicks and drags, and capture screenshots for analysis by multimodal models.

## CSS for Design

In Lynx 3.6, CSS takes on a more explicit role in design systems.
CSS serves as **a medium for expressing design intent**, spanning how decisions are scoped and composed, and how visual structure and perception are formed in the interface.

This release focuses on improving CSS expressiveness through **CSS variables**, **gradients**, and **filters**.

### Inline CSS Variables for Computable Styling

In Lynx 3.6, CSS variables can be defined and referenced inline. This allows CSS variables to be applied at **component boundaries** (where JS-defined parameters are resolved by CSS) directly, without relying on ancestor class switches (such as `theme-light` / `theme-dark`) or imperative JS `setProperty` calls.

It becomes essential when a component's style is user-selected or computed at runtime, since such continuous values cannot be represented by a finite set of predefined classes and would otherwise require imperative style updates.

```tsx
style={{
  '--x': pointer.x,  // normalized parameter from JS
  backgroundColor: 'var(--dot-accent-color)', //defer resolution to component CSS
}}
```

In this case, inline CSS variables allow design parameters to be passed from JS into CSS's inheritance and computation model, enabling design intent to be dynamically expressed and resolved while preserving component-level scoping and the declarative styling model.

<Go
  example="design-guide"
  defaultFile="src/force_field/field.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/design-guide/design_force_field_10fps.webp"
  entry="src/force_field"
  defaultEntryFile="dist/force_field.lynx.bundle"
/>

### Nested CSS Variables for Token Layering

CSS variables in Lynx 3.6 can be defined in terms of other variables, allowing design tokens to be layered and resolved compositionally.
Design tokens capture high-level design decisions, such as colors, typography, spacing, shadows, and glows. Through nested CSS variables, these decisions are progressively resolved into component-level variables and concrete visual styles. By expressing these relationships directly in CSS, the design system embeds itself explicitly in both the code structure and styling logic, going beyond naming conventions and documentation.

```css
.theme-light {
  --theme-canvas: #ffffff;
  --theme-content: #111827;
}

.card {
  /* Component variables reference global theme variables */
  --card-bg: var(--theme-canvas);
  --card-text: var(--theme-content);
  background: var(--card-bg);
  color: var(--card-text);
  padding: 16px;
  border-radius: 12px;
}
```

### Conic Gradients as Design Surfaces

Lynx 3.6 adds support for the `conic-gradient()` CSS image function. You can use it in CSS properties that accept image values, such as in `background-image` and `mask-image`, to create continuous angular color transitions directly in CSS.

```css
.bg {
  background-image: conic-gradient(from 30deg, #ff7385, #fe69a1, #00d0f1);
}
```

Conic gradients are a natural fit for angular or cyclic representations, including color wheels and hue pickers. In practice, they function as lightweight design surfaces that can be composed into interactive controls and visual tools.

<Go
  example="design-guide"
  defaultFile="src/color_wheels/index.css"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/design-guide/design_color_wheels.jpg"
  entry="src/color_wheels"
  defaultEntryFile="dist/color_wheels.lynx.bundle"
/>

### CSS Filters for Shape Formation

Lynx 3.6 extends CSS filter support with `contrast`, `brightness`, and `saturate`.

Rather than serving only as visual tweaks, CSS filters can be composed to participate in the formation of shapes.
In Lynx 3.6, the newly supported `contrast` filter, when combined with the existing `blur` capability, amplifies overlapping regions and allows soft shapes to merge into coherent forms.

Visual structures such as merging, perceptual grouping, and fluid boundaries can now be derived directly from CSS, without relying on bitmap assets or custom rendering pipelines.

<Go
  example="design-guide"
  defaultFile="src/gooey_effect/index.css"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/design-guide/design_gooey_effect_24fps.webp"
  entry="src/gooey_effect"
  defaultEntryFile="dist/gooey_effect.lynx.bundle"
/>

## Native APIs

### Standalone BackgroundRuntime on HarmonyOS

HarmonyOS now supports standalone [BackgroundRuntime](/api/lynx-native-api/lynx-background-runtime), aligning more closely with existing Android and iOS capabilities.

With standalone BackgroundRuntime, developers can run JavaScript tasks independently of rendering, or pre-create background runtimes to reduce LynxView initialization latency.

### Asynchronous TemplateBundle Creation on HarmonyOS

On Android and iOS, [`TemplateBundle.fromTemplate`](/api/lynx-native-api/template-bundle/from-template) can be called from any thread. On HarmonyOS, however, ArkTS logic must run on the application's main thread.

To reduce main-thread I/O blocking, Lynx 3.6 introduces asynchronous APIs for creating `TemplateBundle` instances on HarmonyOS:

- [`TemplateBundle.fromTemplateAsync`](/api/lynx-native-api/template-bundle/from-template-async)
- [`TemplateBundle.fromTemplateAsyncWithOption`](/api/lynx-native-api/template-bundle/from-template-async-with-option)

### AutoLayout Support for LynxView on iOS

On iOS, LynxView now supports Auto Layout via [`[LynxView enableAutoLayout]`](/api/lynx-native-api/lynx-view/enable-auto-layout).

When enabled, LynxView can derive layout parameters directly from client-side Auto Layout constraints, eliminating the need to configure layout values manually.

## Upgrade Guide

To upgrade to Lynx 3.6, follow the [integration guide](https://lynxjs.org/3.6/guide/start/integrate-with-existing-apps.html) and update your Lynx dependency versions accordingly.
